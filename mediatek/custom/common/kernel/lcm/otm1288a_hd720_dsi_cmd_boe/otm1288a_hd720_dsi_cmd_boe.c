#ifndef BUILD_LK
#include <linux/string.h>
#endif

#include "lcm_drv.h"

#ifdef BUILD_LK
	#include <platform/mt_gpio.h>
#elif defined(BUILD_UBOOT)
	#include <asm/arch/mt_gpio.h>
#else
	#include <mach/mt_gpio.h>
#endif


#if defined(BUILD_UBOOT)||defined(BUILD_LK)
	#define LCM_PRINT printf
	#ifndef KERN_INFO
		#define KERN_INFO
	#endif
#else
	#define LCM_PRINT printk
#endif

#if 1
#define LCM_DBG(fmt, arg...) \
	LCM_PRINT("[LCM-ILI9806H-HALFRAM-DSI] %s (line:%d) :" fmt "\r\n", __func__, __LINE__, ## arg)
#else
#define LCM_DBG(fmt, arg...) do {} while (0)
#endif


// ---------------------------------------------------------------------------
// Local Constants
// ---------------------------------------------------------------------------
//TN801031 added 2013.06.17
#define TN_DISPLAY 1
//#define TN_DISPLAY 0

#if TN_DISPLAY
	#define FRAME_WIDTH  (720)

	#define FRAME_HEIGHT (1280)
#else
	#define FRAME_WIDTH  (540)
	#define FRAME_HEIGHT (960)
#endif
//TN801031 added 2013.06.17

#define LCM_DSI_CMD_MODE    1
#define LCM_ID (0x1288)

#define REGFLAG_DELAY 0xAB
#define REGFLAG_END_OF_TABLE 0xAA // END OF REGISTERS MARKER

#define LCM_ID1 0x00
#define LCM_ID2 0x00
#define LCM_ID3 0x00

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

//#define LCM_DSI_CMD_MODE									1

// ---------------------------------------------------------------------------
// Local Variables
// ---------------------------------------------------------------------------

static LCM_UTIL_FUNCS lcm_util = {0};

#define SET_RESET_PIN(v) (lcm_util.set_reset_pin((v)))

#define UDELAY(n) (lcm_util.udelay(n))
#define MDELAY(n) (lcm_util.mdelay(n))


// ---------------------------------------------------------------------------
// Local Functions
// ---------------------------------------------------------------------------

#define dsi_set_cmdq_V2(cmd, count, ppara, force_update) lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
#define dsi_set_cmdq(pdata, queue_size, force_update) lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
#define wrtie_cmd(cmd) lcm_util.dsi_write_cmd(cmd)
#define write_regs(addr, pdata, byte_nums) lcm_util.dsi_write_regs(addr, pdata, byte_nums)
#define read_reg(cmd) lcm_util.dsi_dcs_read_lcm_reg(cmd)
#define read_reg_v2(cmd, buffer, buffer_size) lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size) 

struct LCM_setting_table {
unsigned char cmd;
unsigned char count;
unsigned char para_list[64];
};

static struct LCM_setting_table lcm_initialization_setting[] = {
			
// SSD2825_Gen_write_1A_1P(0x00,0x00);
//SSD2825_Gen_write_1A_3P(0xff,0x12,0x88,0x01); //EXTC=1
// SSD2825_Gen_write_1A_1P(0x00,0x80);             //Orise mode enable
// SSD2825_Gen_write_1A_2P(0xff,0x12,0x88);

        {0x00, 1, {0x00}},
	 {0xff, 3, {0x12,0x88,0x01}},
	 
	 {0x00, 1, {0x80}},
	 {0xff, 2, {0x12,0x88}},
	 
//-------------------- panel setting ------------------------------------//
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //TCON Setting
 //SSD2825_Gen_write_1A_9P(0xc0,0x00,0x64,0x00,0x10,0x10,0x00,0x64,0x10,0x10);
        {0x00, 1, {0x80}},
	 {0xc0, 9, {0x00,0x64,0x00,0x10,0x10,0x00,0x64,0x10,0x10}},
// SSD2825_Gen_write_1A_1P(0x00,0x90);             //Panel Timing Setting
// SSD2825_Gen_write_1A_6P(0xc0,0x00,0x00,0x00,0x20,0x00,0x27);
        {0x00, 1, {0x90}},
	 {0xc0, 6, {0x00,0x00,0x00,0x20,0x00,0x27}},
 //SSD2825_Gen_write_1A_1P(0x00,0xa3);             //source pre. 
 //SSD2825_Gen_write_1A_1P(0xc0,0x00);
        {0x00, 1, {0xa3}},
	 {0xc0, 1, {0x00}},
	 
 //SSD2825_Gen_write_1A_1P(0x00,0xb3);             //column inversion
 //SSD2825_Gen_write_1A_1P(0xc0,0x00);        
        {0x00, 1, {0xb3}},
	 {0xc0, 1, {0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //source bias 1uA
 //SSD2825_Gen_write_1A_1P(0xc4,0x43);
        {0x00, 1, {0x80}},
	 {0xc4, 1, {0x43}},
 //SSD2825_Gen_write_1A_1P(0x00,0xa2);             //switch blank
 //SSD2825_Gen_write_1A_1P(0xc1,0x41);
        {0x00, 1, {0xa2}},
	 {0xc1, 1, {0x41}},
// SSD2825_Gen_write_1A_1P(0x00,0xb6);             //mipi bias
// SSD2825_Gen_write_1A_1P(0xb0,0x18);
        {0x00, 1, {0xb6}},
	 {0xb0, 1, {0x18}},
//-------------------------------------- Power IC-------------------------//
// SSD2825_Gen_write_1A_1P(0x00,0x80);             //2x
// SSD2825_Gen_write_1A_1P(0xc5,0x53);
        {0x00, 1, {0x80}},
	 {0xc5, 1, {0x53}},
// SSD2825_Gen_write_1A_1P(0x00,0x93);             //frequency
// SSD2825_Gen_write_1A_1P(0xc5,0x66);
        {0x00, 1, {0x93}},
	 {0xc5, 1, {0x66}},
//-------------------- power setting -------------------------------------//
// SSD2825_Gen_write_1A_1P(0x00,0xa0);             //dcdc setting (PFM Fre)
// SSD2825_Gen_write_1A_14P(0xc4,0x05,0x10,0x06,0x02,0x05,0x15,0x10,0x05,0x10,0x07,0x02,0x05,0x15,0x10);
        {0x00, 1, {0xa0}},
	 {0xc4, 14, {0x05,0x10,0x06,0x02,0x05,0x15,0x10,0x05,0x10,0x07,0x02,0x05,0x15,0x10}},
 //SSD2825_Gen_write_1A_1P(0x00,0xb0);             //clamp voltage setting
 //SSD2825_Gen_write_1A_3P(0xc4,0x00,0x00,0x03);
         {0x00, 1, {0xb0}},
	 {0xc4, 3, {0x00,0x00,0x03}},

 //SSD2825_Gen_write_1A_1P(0x00,0x91);             //VGH=12V, VGL=-12V, pump ratio:VGH=6x, VGL=-6x
 //SSD2825_Gen_write_1A_2P(0xc5,0x36,0x19);
         {0x00, 1, {0x91}},
	 {0xc5, 2, {0x36,0x19}},
 //SSD2825_Gen_write_1A_1P(0x00,0x00);             //GVDD=4.87V, NGVDD=-4.87V
 //SSD2825_Gen_write_1A_2P(0xd8,0xbc,0xbc);
         {0x00, 1, {0x00}},
	 {0xd8, 2, {0xbc,0xbc}},
// SSD2825_Gen_write_1A_1P(0x00,0xc2);             //LVD voltage level setting
// SSD2825_Gen_write_1A_1P(0xc5,0xb1);
         {0x00, 1, {0xc2}},
	 {0xc5, 1, {0xb1}},
// SSD2825_Gen_write_1A_1P(0x00,0xe1);             //LVD detector
// SSD2825_Gen_write_1A_1P(0xf5,0x55);
         {0x00, 1, {0xe1}},
	 {0xf5, 1, {0x55}},
// SSD2825_Gen_write_1A_1P(0x00,0xc2);    //VGLO1 power sequence disable 
// SSD2825_Gen_write_1A_2P(0xf5,0x00,0x00);
         {0x00, 1, {0xc2}},
	 {0xf5, 2, {0x00, 0x00}},
	 
 //SSD2825_Gen_write_1A_1P(0x00,0xc4);    //VGLO2 power sequence disable
 //SSD2825_Gen_write_1A_2P(0xf5,0x00,0x00);
         {0x00, 1, {0xc4}},
	 {0xf5, 2, {0x00, 0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xc6);    //VGLO2_s power sequence disable
 //SSD2825_Gen_write_1A_2P(0xf5,0x00,0x00);
         {0x00, 1, {0xc6}},
	 {0xf5, 2, {0x00, 0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xf3);             //VGLO enable
 //SSD2825_Gen_write_1A_1P(0xcf,0x34);
         {0x00, 1, {0xf3}},
	 {0xcf, 1, {0x34}},
// SSD2825_Gen_write_1A_1P(0x00,0x83);    //VGLO1/2 Pull low setting
// SSD2825_Gen_write_1A_1P(0xc5,0x30);  //d[5] vglo1 d[4] vglo2 => 0: pull vss, 1: pull vgl
         {0x00, 1, {0x83}},
	 {0xc5, 1, {0x30}},


//-------------------- GAMMA TUNING ---------------------------------------//
// SSD2825_Gen_write_1A_1P(0x00,0x00);            
// SSD2825_Gen_write_1A_20P(0xE1,0x1c,0x24,0x2b,0x34,0x3f,0x4a,0x4b,0x77,0x67,0x84,0x7c,0x63,0x70,0x46,0x41,0x34,0x27,0x1f,0x1f,0x1f);
         //{0x00, 1, {0x00}},
	 //{0xE1, 20, {0x1c,0x24,0x2b,0x34,0x3f,0x4a,0x4b,0x77,0x67,0x84,0x7c,0x63,0x70,0x46,0x41,0x34,0x27,0x1f,0x1f,0x1f}},
//-------------------- GAMMA TUNING ---------------------------------------//

// SSD2825_Gen_write_1A_1P(00,00);            
// SSD2825_Gen_write_1A_20P(E1,00,0e,18,23,30,3d,3e,5d,4d,6a,99,88,99,73,66,55,42,2f,22,00);
         {0x00, 1, {0x00}},
	 //{0xE1, 20, {0x00,0x0e,0x18,0x23,0x30,0x3d,0x3e,0x5d,0x4d,0x6a,0x99,0x88,0x99,0x73,0x66,0x55,0x42,0x2f,0x22,0x00}},
	 {0xE1, 20, {0x00,0x0e,0x1a,0x25,0x34,0x42,0x44,0x71,0x63,0x7e,0x83,0x6b,0x76,0x42,0x39,0x26,0x15,0x09,0x04,0x00}},		//add by lishengli 20140115

// SSD2825_Gen_write_1A_1P(00,00);            
 //SSD2825_Gen_write_1A_20P(E2,00,0e,18,23,30,3d,3e,5d,4d,6a,99,88,99,73,66,55,42,2f,22,00);
        {0x00, 1, {0x00}},
	 //{0xE2, 20, {0x00,0x0e,0x18,0x23,0x30,0x3d,0x3e,0x5d,0x4d,0x6a,0x99,0x88,0x99,0x73,0x66,0x55,0x42,0x2f,0x22,0x00}},
	 {0xE2, 20, {0x00,0x0e,0x1a,0x25,0x34,0x41,0x44,0x71,0x63,0x7e,0x84,0x6a,0x76,0x42,0x39,0x26,0x15,0x09,0x04,0x00}},		//add by lishengli 20140115
// SSD2825_Gen_write_1A_1P(0x00,0x00);            
// SSD2825_Gen_write_1A_20P(0xE2,0x1c,0x24,0x2b,0x34,0x3f,0x4a,0x4b,0x77,0x67,0x84,0x7c,0x63,0x70,0x46,0x41,0x34,0x27,0x1f,0x1f,0x1f);
         //{0x00, 1, {0x00}},
	 //{0xE2, 20, {0x1c,0x24,0x2b,0x34,0x3f,0x4a,0x4b,0x77,0x67,0x84,0x7c,0x63,0x70,0x46,0x41,0x34,0x27,0x1f,0x1f,0x1f}},



//-------------------- panel timing state control -------------------------//
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //panel timing state control
 //SSD2825_Gen_write_1A_11P(0xcb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
        {0x00, 1, {0x80}},
	 {0xcb, 11, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
	 
 //SSD2825_Gen_write_1A_1P(0x00,0x90);             //panel timing state control
// SSD2825_Gen_write_1A_15P(0xcb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0x90}},
	 {0xcb, 15, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
// SSD2825_Gen_write_1A_1P(0x00,0xa0);             //panel timing state control
// SSD2825_Gen_write_1A_15P(0xcb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0xa0}},
	 {0xcb, 15, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
// SSD2825_Gen_write_1A_1P(0x00,0xb0);             //panel timing state control
// SSD2825_Gen_write_1A_15P(0xcb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0xb0}},
	 {0xcb, 15, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xc0);             //panel timing state control
 //SSD2825_Gen_write_1A_15P(0xcb,0x05,0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0xc0}},
	 {0xcb, 15, {0x05,0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
// SSD2825_Gen_write_1A_1P(0x00,0xd0);             //panel timing state control
 //SSD2825_Gen_write_1A_15P(0xcb,0x00,0x00,0x00,0x00,0x00,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x00,0x00);
         {0x00, 1, {0xd0}},
	 {0xcb, 15, {0x00,0x00,0x00,0x00,0x00,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xe0);             //panel timing state control
 //SSD2825_Gen_write_1A_14P(0xcb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05);
         {0x00, 1, {0xe0}},
	 {0xcb, 14, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05}},
 //SSD2825_Gen_write_1A_1P(0x00,0xf0);             //panel timing state control
 //SSD2825_Gen_write_1A_11P(0xcb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff);
         {0x00, 1, {0xf0}},
	 {0xcb, 11, {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}},
//-------------------- panel pad mapping control ---------------------------//
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //panel pad mapping control
 //SSD2825_Gen_write_1A_15P(0xcc,0x0a,0x0c,0x0e,0x10,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0x80}},
	 {0xcc, 15, {0x0a,0x0c,0x0e,0x10,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
// SSD2825_Gen_write_1A_1P(0x00,0x90);             //panel pad mapping control
// SSD2825_Gen_write_1A_15P(0xcc,0x00,0x00,0x00,0x00,0x00,0x2e,0x2d,0x09,0x0b,0x0d,0x0f,0x01,0x03,0x00,0x00);
         {0x00, 1, {0x90}},
	 {0xcc, 15, {0x00,0x00,0x00,0x00,0x00,0x2e,0x2d,0x09,0x0b,0x0d,0x0f,0x01,0x03,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xa0);             //panel pad mapping control
 //SSD2825_Gen_write_1A_14P(0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2e,0x2d);
         {0x00, 1, {0xa0}},
	 {0xcc, 14, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2e,0x2d}},
 //SSD2825_Gen_write_1A_1P(0x00,0xb0);             //panel pad mapping control
 //SSD2825_Gen_write_1A_15P(0xcc,0x0F,0x0D,0x0B,0x09,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00); 
         {0x00, 1, {0xb0}},
	 {0xcc, 15, {0x0F,0x0D,0x0B,0x09,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xc0);             //panel pad mapping control
 //SSD2825_Gen_write_1A_15P(0xcc,0x00,0x00,0x00,0x00,0x00,0x2d,0x2e,0x10,0x0E,0x0C,0x0A,0x04,0x02,0x00,0x00); 
         {0x00, 1, {0xc0}},
	 {0xcc, 15, {0x00,0x00,0x00,0x00,0x00,0x2d,0x2e,0x10,0x0E,0x0C,0x0A,0x04,0x02,0x00,0x00}},
// SSD2825_Gen_write_1A_1P(0x00,0xd0);             //panel pad mapping control
// SSD2825_Gen_write_1A_14P(0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2d,0x2e); 
         {0x00, 1, {0xd0}},
	 {0xcc, 14, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2d,0x2e}},
//-------------------- panel timing setting --------------------------------//
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //panel VST setting
 //SSD2825_Gen_write_1A_12P(0xce,0x8b,0x03,0x00,0x8a,0x03,0x00,0x89,0x03,0x00,0x88,0x03,0x00);
         {0x00, 1, {0x80}},
	 {0xce, 12, {0x8b,0x03,0x00,0x8a,0x03,0x00,0x89,0x03,0x00,0x88,0x03,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xa0);             //panel CLKA1/2 setting
 //SSD2825_Gen_write_1A_14P(0xce,0x38,0x09,0x84,0xfd,0x8b,0x10,0x10,0x38,0x08,0x84,0xfe,0x8b,0x10,0x10);
         {0x00, 1, {0xa0}},
	 {0xce, 14, {0x38,0x09,0x84,0xfd,0x8b,0x10,0x10,0x38,0x08,0x84,0xfe,0x8b,0x10,0x10}},
 //SSD2825_Gen_write_1A_1P(0x00,0xb0);             //panel CLKA3/4 setting
 //SSD2825_Gen_write_1A_14P(0xce,0x38,0x07,0x84,0xff,0x8b,0x10,0x10,0x38,0x06,0x85,0x00,0x8b,0x10,0x10);
         {0x00, 1, {0xb0}},
	 {0xce, 14, {0x38,0x07,0x84,0xff,0x8b,0x10,0x10,0x38,0x06,0x85,0x00,0x8b,0x10,0x10}},
 //SSD2825_Gen_write_1A_1P(0x00,0xc0);             //panel CLKb1/2 setting
 //SSD2825_Gen_write_1A_14P(0xce,0x38,0x05,0x85,0x01,0x8b,0x10,0x10,0x38,0x04,0x85,0x02,0x8b,0x10,0x10);
         {0x00, 1, {0xc0}},
	 {0xce, 14, {0x38,0x05,0x85,0x01,0x8b,0x10,0x10,0x38,0x04,0x85,0x02,0x8b,0x10,0x10}},
 //SSD2825_Gen_write_1A_1P(0x00,0xd0);             //panel CLKb3/4 setting
 //SSD2825_Gen_write_1A_14P(0xce,0x38,0x03,0x85,0x03,0x8b,0x10,0x10,0x38,0x02,0x85,0x04,0x8b,0x10,0x10);
         {0x00, 1, {0xd0}},
	 {0xce, 14, {0x38,0x03,0x85,0x03,0x8b,0x10,0x10,0x38,0x02,0x85,0x04,0x8b,0x10,0x10}},
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //panel CLKc1/2 setting
 //SSD2825_Gen_write_1A_14P(0xcf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0x80}},
	 {0xcf, 14, {0xcf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0x90);             //panel CLKc3/4 setting
 //SSD2825_Gen_write_1A_14P(0xcf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0x90}},
	 {0xcf, 14, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xa0);             //panel CLKd1/2 setting
 //SSD2825_Gen_write_1A_14P(0xcf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0xa0}},
	 {0xcf, 14, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xb0);             //panel CLKd3/4 setting
 //SSD2825_Gen_write_1A_14P(0xcf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0xb0}},
	 {0xcf, 14, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
 //SSD2825_Gen_write_1A_1P(0x00,0xc0);             //panel ECLK setting, gate pre. ena.
 //SSD2825_Gen_write_1A_9P(0xcf,0x01,0x20,0x00,0x00,0x01,0x01,0x00,0x00,0x08); 
         {0x00, 1, {0xc0}},
	 {0xcf, 9, {0x01,0x20,0x00,0x00,0x01,0x01,0x00,0x00,0x08}},
 //SSD2825_Gen_write_1A_1P(0x00,0x80);             //TCON_GOA_OUT Setting
 //SSD2825_Gen_write_1A_6P(0xf3,0x00,0x00,0x00,0x00,0x00,0x00);
         {0x00, 1, {0x80}},
	 {0xf3, 6, {0x00,0x00,0x00,0x00,0x00,0x00}},
	 //BEGIN add by panchenjun 20131223
//> SSD2825_Gen_write_1A_1P(0x00,0x92); //VCL disable 
//> SSD2825_Gen_write_1A_2P(0xf5,0x00,0x00); 
        {0x00, 1, {0x92}},
	{0xf5, 2, {0x00,0x00}}, 

//> SSD2825_Gen_write_1A_1P(0x00,0xc8); //enable VCL regulator 
//> SSD2825_Gen_write_1A_2P(0xf5,0x0b,0x15);

        {0x00, 1, {0xc8}},
	{0xf5, 2, {0x0b,0x15}}, 
    //END  add by panchenjun 20131223

        //{0x00, 1, {0x00}},
	//{0x99, 2, {0x95,0x27}}, 

        
	//{0x99,1, {0x00}}, 


	{0x00, 1, {0x00}},
	{0x35,1,{0x00}},
	
	{0x00, 1, {0x00}},
	{0x44,2,{0x01,0x22}},

         //{0x00, 1, {0x00}},
	 //{0x2A, 4, {0x00,0x00,0x02,0xCF}},

         //{0x00, 1, {0x00}},
	// {0x2B, 4, {0x02,0x7e,0x04,0xff}},
	

 //SSD2825_Gen_write_1A_1P(0x00,0x00);           
 //SSD2825_Gen_write_1A_3P(0xFF,0xFF,0xFF,0xFF);
         {0x00, 1, {0x00}},
	 {0xff, 3, {0xFF,0xFF,0xFF}},

	
        {0x11,0,{}},
        {REGFLAG_DELAY, 100, {}},
        {0x29,0,{}},
        {REGFLAG_DELAY, 20, {}},





        
        //{0x99, 2, {0x00,0x00}},// lock in
        ////{0x2C,0,{}},        //mask for test tcp
        {REGFLAG_END_OF_TABLE, 0x00, {}}    //add test tcp
        ////{REGFLAG_DELAY, 150, {}}, //50
};

static struct LCM_setting_table lcm_sleep_out_setting[] = {
// Sleep Out
{0x99, 2, {0x95,0x27}}, // lock out

{0x11, 1, {0x00}},
{REGFLAG_DELAY, 100, {}},

// Display ON
{0x29, 1, {0x00}},
{REGFLAG_DELAY, 150, {}},    //add test tcp

//{0x99, 2, {0x00,0x00}},// lock in

{0x99, 2, {0x95,0x27}}, // lock out

	{REGFLAG_END_OF_TABLE, 0x00, {}}
};


static struct LCM_setting_table lcm_deep_sleep_mode_in_setting[] = {
// Display off sequence

{0x99, 2, {0x95,0x27}}, // lock out

{0x28, 1, {0x00}},
{REGFLAG_DELAY, 10, {}},
// Sleep Mode On
{0x10, 1, {0x00}},
{REGFLAG_DELAY, 50, {}}, 

//{0x99, 2, {0x00,0x00}},// lock in
{0x99, 2, {0x95,0x27}}, // lock out
{REGFLAG_DELAY, 10, {}}, 



{REGFLAG_END_OF_TABLE, 0x00, {}}
};

static struct LCM_setting_table lcm_backlight_level_setting[] = {
{0x51, 1, {0xFF}},
{REGFLAG_END_OF_TABLE, 0x00, {}}
};


static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
{
	unsigned int i;

	for(i = 0; i < count; i++) {

		unsigned cmd;
		cmd = table[i].cmd;

		switch (cmd) {
			case REGFLAG_DELAY :
			MDELAY(table[i].count);
			break;

			case REGFLAG_END_OF_TABLE :
			break;

			default:
			dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update); 
		}
	}
}

// ---------------------------------------------------------------------------
// LCM Driver Implementations
// ---------------------------------------------------------------------------

static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
{
	memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
}


static void lcm_get_params(LCM_PARAMS *params)
{
		memset(params, 0, sizeof(LCM_PARAMS));
	
		params->type   = LCM_TYPE_DSI;

		params->width  = FRAME_WIDTH;
		params->height = FRAME_HEIGHT;

        #if (LCM_DSI_CMD_MODE)
		params->dsi.mode   = CMD_MODE;
        #else
		params->dsi.mode   = BURST_VDO_MODE; //SYNC_PULSE_VDO_MODE;//BURST_VDO_MODE; 
        #endif

		//params->dbi.te_mode = LCM_DBI_TE_MODE_VSYNC_ONLY;		//tinnohd.add test tcp

		params->dbi.te_edge_polarity        = LCM_POLARITY_RISING;
		params->dbi.te_mode                 = LCM_DBI_TE_MODE_VSYNC_ONLY;

		// DSI
		/* Command mode setting */
		//1 Three lane or Four lane
		params->dsi.LANE_NUM				= LCM_FOUR_LANE;			//LCM_THREE_LANE;
		//The following defined the fomat for data coming from LCD engine.
		params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
		params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
		params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
		params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;

		// Video mode setting		
		////params->dsi.intermediat_buffer_num = 0;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage

		params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;


		params->dsi.word_count=(FRAME_WIDTH)*3;	

		//params->dsi.HS_PRPR=3;
		//params->dsi.CLK_HS_POST = 26;
		//方案二
		//params->dsi.PLL_CLOCK = LCM_DSI_6589_PLL_CLOCK_325;//LCM_DSI_6589_PLL_CLOCK_260;//LCM_DSI_6589_PLL_CLOCK_286
		//方案一
		//params->dsi.PLL_CLOCK = 250;
		///	params->dsi.LPX		= 80;///bbk add

		// Highly depends on LCD driver capability.
		// Not support in MT6573
		params->dsi.packet_size=256;
		//params->dsi.PLL_CLOCK = 250;//songyutao test

		params->dsi.pll_div1=0;		// div1=0,1,2,3;div1_real=1,2,4,4 ----0: 546Mbps  1:273Mbps
		params->dsi.pll_div2=1;		// div2=0,1,2,3;div1_real=1,2,4,4	
		params->dsi.fbk_div =17;  //songyutao 17 to 23  // fref=26MHz, fvco=fref*(fbk_div+1)*2/(div1_real*div2_real)	
		//songyutao test
		#if 0
		params->dsi.HS_PRPR=3;
		params->dsi.CLK_HS_POST = 26;
		params->dsi.DA_HS_EXIT =35;
		params->dsi.pll_div1=1;		// div1=0,1,2,3;div1_real=1,2,4,4 ----0: 546Mbps  1:273Mbps
		params->dsi.pll_div2=1;		// div2=0,1,2,3;div1_real=1,2,4,4	
		params->dsi.fbk_div =19;    // fref=26MHz, fvco=fref*(fbk_div+1)*2/(div1_real*div2_real)	

		params->dsi.noncont_clock = TRUE;
		params->dsi.noncont_clock_period = 2;	// Unit : frames	
		#endif
		//end
}

static void lcm_init(void)
{
    SET_RESET_PIN(1);
    MDELAY(10);
    SET_RESET_PIN(0);
    MDELAY(50);//Must > 10ms
    SET_RESET_PIN(1);
    MDELAY(60);//Must > 120ms
#if 1
	push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
#else
	lcm_init_register();
#endif
LCM_DBG("tcp_test:lcm_init\n");
}


static void lcm_suspend(void)
{
	push_table(lcm_deep_sleep_mode_in_setting, sizeof(lcm_deep_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);

// push_table(lcm_sleep_in_setting, sizeof(lcm_sleep_in_setting) / sizeof(struct LCM_setting_table), 1);

//    SET_RESET_PIN(0);	
//    MDELAY(1);	
//    SET_RESET_PIN(1);
/*
  unsigned int data_array[16];
	
	data_array[0] = 0x00280500; 
	dsi_set_cmdq(data_array, 1, 1);
	data_array[0] = 0x00100500; 
	dsi_set_cmdq(data_array, 1, 1);
    
	#ifndef BUILD_LK
	extern void emmc_get_id_test(void);//songyutao
	//emmc_get_id_test();
	#endif	
//LCM_DBG("tcp_test:lcm_suspend\n");

*/
     #ifndef BUILD_LK
    printk("lcm_suspend ");
    #endif
}


static void lcm_resume(void)
{
	//lcm_init();
	push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
}

static unsigned int lcm_esd_check(void);
static void lcm_update(unsigned int x, unsigned int y, unsigned int width, unsigned int height)
{

    unsigned int x0 = x;
    unsigned int y0 = y;
    unsigned int x1 = x0 + width - 1;
    unsigned int y1 = y0 + height - 1;

    unsigned char x0_MSB = ((x0>>8)&0xFF);
    unsigned char x0_LSB = (x0&0xFF);
    unsigned char x1_MSB = ((x1>>8)&0xFF);
    unsigned char x1_LSB = (x1&0xFF);
    unsigned char y0_MSB = ((y0>>8)&0xFF);
    unsigned char y0_LSB = (y0&0xFF);
    unsigned char y1_MSB = ((y1>>8)&0xFF);
    unsigned char y1_LSB = (y1&0xFF);

    unsigned int data_array[16];

	data_array[0]= 0x00033902;
	data_array[1]= 0x00279599; //lock out 
	dsi_set_cmdq(data_array, 2, 1);

	data_array[0]= 0x00053902;
	data_array[1]= (x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a;
	data_array[2]= (x1_LSB);
	dsi_set_cmdq(data_array, 3, 1);

	data_array[0]= 0x00053902;
	data_array[1]= (y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b;
	data_array[2]= (y1_LSB);
	dsi_set_cmdq(data_array, 3, 1);

	data_array[0]= 0x00033902;
	data_array[1]= 0x00279599; //lock out 
	dsi_set_cmdq(data_array, 2, 1);
   
	data_array[0]= 0x002c3909;
	dsi_set_cmdq(data_array, 1, 0);

}

static void lcm_setbacklight(unsigned int level)
{
// Refresh value of backlight level.
//lcm_backlight_level_setting[0].para_list[0] = level;

//push_table(lcm_backlight_level_setting, sizeof(lcm_backlight_level_setting) / sizeof(struct LCM_setting_table), 1);
}

static unsigned int lcm_compare_id(void)
{

    int array[4];
    char buffer[5];
    char id_high=0;
    char id_low=0;
    int id=0;

    SET_RESET_PIN(0);
    MDELAY(25);
    SET_RESET_PIN(1);
    MDELAY(100);

    array[0] = 0x00053700;// read id return two byte,version and id
    dsi_set_cmdq(array, 1, 1);
    read_reg_v2(0xA1,buffer, 5);

    id_high = buffer[2]; //should be 0x80
    id_low = buffer[3]; //should be 0x09
    id = (id_high<<8)|id_low; //should be 0x8009

    #ifdef BUILD_LK
    printf("otm1288a uboot %s\n", __func__);
    printf("%s, id = 0x%08x\n", __func__, id);//should be 0x1289
    #else
    printk("otm1288a kernel %s\n", __func__);
    printk("%s, id = 0x%08x\n", __func__, id);//should be 0x1289
    #endif

    return (LCM_ID == id)?1:0;
}


static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
extern void Tinno_set_HS_read();
extern void Tinno_restore_HS_read();

static unsigned int lcm_esd_check(void)
{

    unsigned char buffer[5],ret;
    int   array[4];
    
#ifndef BUILD_UBOOT

    if(lcm_esd_test)
    {
        lcm_esd_test = FALSE;
        return TRUE;
    }
    
    array[0] = 0x00013700;
    dsi_set_cmdq(array, 1, 1);
    read_reg_v2(0xAC, buffer,1);
    #ifndef BUILD_LK
        printk("[JX] %s 0xac 0=0x%x \n",__func__,buffer[0]);
    #endif
    if(buffer[0]==0x00){
        ret = 0;
    }else{
        ret = 1;
    }

    #ifndef BUILD_LK
        printk("[JX] %s ret=%d \n",__func__,ret);
    #endif
	if(ret) 
            return TRUE;


    	array[0] = 0x00013700;
    	dsi_set_cmdq(array, 1, 1);
    	read_reg_v2(0x0A, buffer,1);//0x0a ---1
    	#ifndef BUILD_LK
    	printk("[JX] %s 0x0a 0=0x%x  \n",__func__,buffer[0]);
    	#endif
            if(buffer[0]==0x9C){
                ret = 0;
            }else{
                ret = 1;
            }

	#ifndef BUILD_LK
	printk("[JX] %s ret=%d \n",__func__,ret);
	#endif
	if(ret) 
            return TRUE;
    
    	array[0] = 0x00013700;
    	dsi_set_cmdq(array, 1, 1);
    	read_reg_v2(0x0D, buffer,1);//0x0D ---1
    	#ifndef BUILD_LK
    	printk("[JX] %s 0x0D 0=0x%x  \n",__func__,buffer[0]);
    	#endif
            if(buffer[0]==0x00){
                ret = 0;
            }else{
                ret = 1;
            }

	#ifndef BUILD_LK
	printk("[JX] %s ret=%d \n",__func__,ret);
	#endif
	if(ret) 
            return TRUE;
	else 
            return FALSE;
    
#endif
}

static unsigned int lcm_esd_recover(void)
{
    lcm_init();
    lcm_resume();
    return TRUE;
}


// ---------------------------------------------------------------------------
// Get LCM Driver Hooks
// ---------------------------------------------------------------------------
LCM_DRIVER otm1288a_hd720_dsi_cmd_boe_lcm_drv = 
{
	.name = "otm1288a_hd720_dsi_cmd_boe",
	.set_util_funcs = lcm_set_util_funcs,
	.get_params = lcm_get_params,
	.init = lcm_init,
	.suspend = lcm_suspend,
	.resume = lcm_resume,
#if (LCM_DSI_CMD_MODE)
	.update = lcm_update,
       // .set_backlight = lcm_setbacklight,
// .set_pwm = lcm_setpwm,
// .get_pwm = lcm_getpwm,
    .esd_check = lcm_esd_check,
    .esd_recover = lcm_esd_recover,
	.compare_id = lcm_compare_id,
#endif
};
